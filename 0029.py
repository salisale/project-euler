'''
29. Distinct powers

Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

2^2=4, 2^3=8, 2^4=16, 2^5=32
3^2=9, 3^3=27, 3^4=81, 3^5=243
4^2=16, 4^3=64, 4^4=256, 4^5=1024
5^2=25, 5^3=125, 5^4=625, 5^5=3125

If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?

'''

limit = 100

###############################################
# Smart brute-force way
###############################################
res = set()
for i in range(2,limit+1):
	for j in range(2,limit+1):
		res.add(i**j)

print(len(res)) # 9183


#################################################
# Roundabout not-sure-what-im-accomplishing way
#################################################
def findFactors(x):
	return [(y,int(x/y)) for y in range(2,int(x**0.5)+1) if x%y==0] # excl. 1

productMap = dict() # a dict of product as key, all power forms as value
				# e.g. 
				#     10367793076318844190248738727596255138212949486449  :  {(49, 29), (7, 58)}
				#     4638397686588101979328150167890591454318967698009  :  {(9, 51), (27, 34)}
				
for x in range(2,limit+1):
	for y in range(2,limit+1):
		forms = set()
		factors = findFactors(y)
		for pair in factors:
			a, b = x**pair[0], pair[1] # first possible pair e.g. 4^6
			c, d = x**pair[1], pair[0] # find second possible pair
			if a <= limit and b <= limit:
				forms.add((a,b))
			if c <= limit and d <= limit:
				forms.add((c,d))
		forms.add((x,y))

		product = x**y
		if product not in productMap:
			productMap[product] = set()
		productMap[product] = productMap[product].union(forms)

# ... ??
print(len(productMap.keys())) # !!!
